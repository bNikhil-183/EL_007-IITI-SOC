module  baugh_wooley_multiplier (
    input  signed [15:0] a,
    input  signed [15:0] b,
    output signed [31:0] product
);

wire [31:0] p [15:0]; // partial products(32*16 bit)
reg [31:0] sum;
integer k,j ;
genvar i;

generate
   for (i = 0; i < 16; i = i + 1) 
      begin
         if (j >= i && j < i + 16)
             assign p[i][j] = ((i == 15) ^ (j - i == 15)) ? ~(a[i] & b[j - i]) : (a[i] & b[j - i]); 
                 //if only one MSB is multiplied with other bits, then it should be inverted
         else
             assign p[i][j] = 1'b0; //unused upper bits = 0
       end
endgenerate

always @(*)
    begin
       sum = 32'h00008000; // error when taking the 2's complement(2^15)
          for (k = 0; k < 16; k++) sum = sum + p[k]; // adding all partial products
     end

assign product = sum;

endmodule


